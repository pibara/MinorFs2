#!/usr/bin/python
import fuse
fuse.fuse_python_api = (0, 2)
import hashlib
import base64
import os
import stat
import json
import sys
import errno
class Lookup:
    def __init__(self,rawstoragerootdir,salt):
        self.rawstoragerootdir = rawstoragerootdir
        self.salt=salt
    def statfs(self):
        return os.statvfs(self.rawstoragerootdir)
    def __pcall(self,accesstoken,relpath,succeedcreatable):
        #A valid basecap is 55 characters long.
        if len(accesstoken) != 55:
            return NoNode()
        #The access token starts with either 'rw-' or 'ro-'
        mode=accesstoken[:2]
        #The rest is the base32 representation of a 256 bit key.
        basecapb32=accesstoken[3:]
        #Turn it into a raw 256 bit key.
        try:
            basecapraw=base64.b32decode(basecapb32 + "====")
        except TypeError:
            return NoNode()
        #Initialize the base keys to None.
        rwcap=None
        rocap=None
        cryptokey=None
        if (mode=='rw'):
            #If its a read only token, remember that
            readonly = False
            #Remember the base32 key as rw-cap
            rwcap=accesstoken
            #Calculate the crypto-key key from the raw read/write key and our secret salt.
            cryptokey = str(hashlib.sha256(basecapraw + self.salt ).digest())
            #The read-only key is the base32 of the crypto-key.
            rocap = "ro-" + base64.b32encode(cryptokey)[:52]
        elif (mode=='ro'):
            #If its a read/write access token, remember that.
            readonly = True
            #The crypto-key is the raw basecap.
            cryptokey== basecapraw
            #The supplied basecap is our read only cap.
            rocap=accesstoken
        else:
            #Anything else is bogus.
            return NoNode()
        #Set parentrocap to None in case whe have an empty relpath.
        parentcryptokey=None
        for subnodename in relpath.split("/"):
            #Remember the last parent cryptokey, we may need it later on.
            parentcryptokey=cryptokey
            #Calculate all relevant caps from the parent ro cap and the subnode name.
            rwkey=str(hashlib.sha256( parentcryptokey + self.salt + subnodename ).digest())
            cryptokey=str(hashlib.sha256( rwkey + self.salt ).digest())
        #Now first look at the leaf node only, calculate the storage key, storage path and check it it exists.
        storagekey = base64.b32encode(str(hashlib.sha256(cryptokey + self.salt ).digest()))[:52]  
        storagepath = "/" + storagekey[:2] + "/" + storagekey[2:4] + "/" + storagekey[4:]      
        basenode = self.rawstoragerootdir.pathToNode(storagepath)
        if not basenode.exists():
            if succeedcreatable:
                #If it does not exist, that might be OK if the succeedcreatable function argument is set.
                if parentrocap:
                    #If we do have a parent node but our current node does not exist and is directory,than at least our parent node MUST exist.
                    parentstoragekey = base64.b32encode(str(hashlib.sha256(parentcryptokey + self.salt ).digest()))[:52]
                    parentstoragepath = "/" + parentstoragekey[:2] + "/" + parentstoragekey[2:4] + "/" + parentstoragekey[4:]
                    parentbasenode = self.rawstoragerootdir.pathToNode(parentstoragepath)
                    if not parentbasenode.isDir():
                        #If it doesn't, the whole path must be bogus.
                        return NoNode()
            else:
                return NoNode()
        #If relpath wasn't empty, calculate the new base32 versions of the relevant keys.
        if not parentcryptokey == None:
            rwcap="rw-" + base64.b32encode(rwkey)[:52]
            rocap="ro-" + base64.b32encode(cryptokey)[:52]
        #Now set the crypto key and the read only flag for the node before we return it.
        if readonly:
            basenode.setMeta(None,rocap,cryptokey)
            return ReadOnlyProxy(basenode)
        else:
            basenode.setMeta(rwcap,rocap,cryptokey)
            return basenode
    def __call__(self,path,succeedcreatable=False):
        if path=="/":
            return TopLevelDir()
        basecap = path.split("/")[1]
        relpath=string.join([""]+path.split("/")[2:],"/")
        return self.__pcall(basecap,relpath,succeedcreatable)
    def parentnode(self,path):
        if path=="/":
            return NoNode()

#Helper class for making the implementation of different cryptoboxes less redundant.
#This class maps random reads and writes to the block boundaries used by the crypto
#module.
class CryptoProxy:
    def __init__(self,cryptobox,cryptoblocksize):
        self.cryptobox=cryptobox
        self.cryptoblocksize=cryptoblocksize
    def read(self,cryptofile,length,offset):
        readoffset=(offset / self.cryptoblocksize) * self.cryptoblocksize
        frontslacksize=readoffset - offset
        tailoffset=frontslacksize + length
        readlength=(((tailoffset -1)/self.cryptoblocksize)+1)*self.cryptoblocksize
        cryptoblock=cryptofile.read(readlength,readoffset)
        block=self.cryptobox.decrypt(readoffset,cryptoblock)
        return block[frontslacksize:tailoffset]    
    def write(self,cryptofile,offset,data):
        length=len(data)
        readoffset=(offset / self.cryptoblocksize) * self.cryptoblocksize
        frontslacksize=readoffset - offset
        tailoffset=frontslacksize + length
        readlength=(((tailoffset -1)/self.cryptoblocksize)+1)*self.cryptoblocksize
        if readlength != length:
            oldcryptoblock=cryptofile.read(readlength,readoffset)
            oldblock=self.cryptobox.decrypt(readoffset,cryptoblock)
            data=oldblock[:frontslacksize] + data + oldblock[readlength:]
        cryptodata=self.cryptobox.encrypt(data)
        return cryptofile.write(readoffset,cryptodata) 


#Simple crypto box for the NULL crypto algoritm.            
class NullCryptoBox:
    def __init__(self,key):
        self.key=key
    def encrypt(self,offset,data):
        return data
    def decrypt(self,offset,data):
        return data

#Simple crypto module for the NULL crypto algoritm.
class NullCryptoModule:
    def getCryptoBox(self,cryptokey):
        cryptobox=NullCryptoBox(cryptokey)
        return CryptoProxy(cryptobox,1) 

#Simple wrapper for access to the raw storage.  
class RawStorageNode:
    #Private function for (re) initializing based on file mode.
    def __dostat(self):
        if os.path.exists(self.fullpath):
            self.exists=True
            self.stat=os.stat(self.fullpath)
            #Given that cap_fs runs as capfs user being the only user in the capfs group, the 'group' access control bits
            #are unused. We use them to piggyback our node type on. 4 represents common files, 6 represents directories and
            #7 represents symbolic links. Other node types are (currently) not supported by cap_fs. 
            self.nodetype = (self.stat.st_mode & 070) >> 3
            #Depending on the type update the mode.
            if self.nodetype == 4:
                #A file is either non executable (0666) or executable (0777)
                if self.stat.st_mode & 0100:
                    self.stat.st_mode = 0777
                else:
                    self.stat.st_mode = 0666
            elif self.nodetype == 6:
                #Directories have mode 0777
                self.stat.st_mode = 0777 & stat.S_IFDIR
            elif self.nodetype == 7:
                #Symbolic links have mode 0777
                self.stat.st_mode = 0777 & stat.S_IFLNK
    #Constructor
    def __init__(self,rootdir,relpath,cryptomodule):
        self.initialized=False
        self.exists=False
        self.nodetype=0
        self.fullpath=rootdir + relpath
        self.stat=None
        self.cryptomodule=cryptomodule
        self.file=None
        self.__dostat()
    def exists(self):
        return self.exists
    def isFile(self):
        return self.nodetype==4
    def isDir(self):
        return self.nodetype==6
    def isLink(self):
        return self.nodetype==7
    #Second step of initialisation
    def setMeta(self,rwcap,rocap,cryptokey):
        if not self.initialized:
            self.initialized = True
            self.rwcap=rwcap
            self.rocap=rocap
            self.cryptobox=self.cryptomodule.getCryptoBox(cryptokey)
        return
    def getattr(self):
        return self.stat
    def getxattr(self,name):
        #The raw storage has a read+write and a read-only attribute.
        if name == "user.cap":
            return self.rwcap
        if name == "user.rocap":
            return self.rocap
    def listxattr(self):
        return ["user.cap","user.rocap"]
    def open(self,flags,mode,nodetype):
        #The 'group' bits are the node type.
        nodetypemask = (nodetype & 0007) << 3
        #All node's are to be r+w, so only the 'x' flag of the mode is relevant.
        exeflag = mode & 0100
        filemode=exeflag | 0600 | nodetypemask
        try:
            myfile=os.open(self.fullpath,flags,filemode)
        except:
            return -EPERM
        if not self.exists:
            #If the file didn't already exist before, run the _dostat initialization again.
            self.__dostat()
        return myfile
    def chmod(mode):
        #All node's are to be r+w, so only the 'x' flag of the mode is relevant.
        exeflag = mode & 0100
        #The 'group' bits are the node type.
        nodetypemask = (self.nodetype & 0007) << 3
        newmode = exeflag | 0600 |  nodetypemask
        os.chmod(self.fullpath,newmode)
        #If the node type is 'file', we update our external mode according to the exe flag.
        if self.nodetype == 4:
            if exeflag:
                self.stat.st_mode = 0777
            else:
                self.stat.st_mode = 0666
    def touch(self):
        os.utime(self.fullpath,None)
    def unlink(self):
        os.unlink(self.fullpath)
    def link(self,path):
        os.link(path,self.fullpath)

#Wrapper class for regular node that disalows any writing action and removes
#the r/w extended attributes from the extended attributes list.
class ReadOnlyProxy:
    def __init__(self,basenode):
        self.basenode=basenode
    def access(self,mode):
        if mode== os.W_OK:
            return False
        return self.basenode.access(mode)
    def chmod(self,mode):
        return -EPERM
    def exists(self):
        return self.basenode.exists()
    def isDir(self):
        return self.basenode.isDir()
    def isFile(self):
        return self.basenode.isFile()
    def isLink(self):
        return self.basenode.isLink()
    def flush(self):
        return -EPERM
    def fsync(isfssyncfile):
        return -EPERM
    def getattr(self):
        return self.basenode.getattr()
    def getxattr(self,name):
        if name="user.rocap":
            return self.basenode.getxattr(name)
        return ""
    def link(self,nodeold,parentnew):
        return -EPERM
    def listxattr(self):
        return ["user.rocap"]
    def mkdir(self,modei,parent):
        return -EPERM
    def open(self,parent,flags,*mode):
        if (flags & (os.O_WRONLY | os.O_APPEND | os.O_CREAT | os.O_TRUNC)):
            return -EPERM
        return self.basenode.open(parent,flags,mode)
    def read(length,offset):
        return self.basenode.read(length,offset)
    def readdir(self):
        return self.basenode.readdir()
    def readlink(self):
        return self.basenode.readlink()
    def release(self,flags):
        return self.basenode.release(flags)
    def rename(self,nodenew,parentold,parentnew):
        return -EPERM
    def rmdir(self,parent):
        return -EPERM
    def setMeta(self,rwcap,rocap,cryptokey):
        return self.basenode.setMeta(None,rocap,cryptokey)
    def symlink(self,pathold,parentnew):
        return -EPERM
    def touch(self):
        return -EPERM
    def truncate(self,len):
        return -EPERM
    def unlink(self,parent):
        return -EPERM
    def write(self,buf,offset):
        return -EPERM

#Node type for no node at all.
class NoNode:
    def access(self,mode):
        return -ENOENT
    def chmod(self,mode):
        return -ENOENT
    def exists(self):
        return False
    def isDir(self):
        return False
    def isFile(self):
        return False
    def isLink(self):
        return False
    def flush(self):
        return -ENOENT
    def fsync(isfssyncfile):
        return -ENOENT
    def getattr(self):
        return -ENOENT
    def getxattr(self,name):
        return -ENOENT
    def link(self,nodeold,parentnew):
        return -ENOENT
    def listxattr(self):
        return -ENOENT
    def mkdir(self,modei,parent):
        return -ENOENT
    def open(self,parent,flags,*mode):
        return -ENOENT
    def read(length,offset):
        return -ENOENT
    def readdir(self):
        return -ENOENT
    def readlink(self):
        return -ENOENT
    def release(self,flags):
        return -ENOENT
    def rename(self,nodenew,parentold,parentnew):
        return -ENOENT
    def rmdir(self,parent):
        return -ENOENT
    def setMeta(self,rwcap,rocap,cryptokey):
        pass
    def symlink(self,pathold,parentnew):
        return -ENOENT
    def touch(self):
        return -ENOENT
    def truncate(self,len):
        return -ENOENT
    def unlink(self,parent):
        return -ENOENT
    def write(self,buf,offset):
        return -ENOENT

#Node representing the no authority cap_fs top dir.
#This basically looks like an empty read only dir.
class TopLevelDir:
    def access(self,mode):
        if mode== os.W_OK:
            return False
        return True
    def chmod(self,mode):
        return -EPERM
    def exists(self):
        return True
    def isDir(self):
        return True
    def isFile(self):
        return False
    def isLink(self):
        return False
    def flush(self):
        return -ENOSUP
    def fsync(isfssyncfile):
        return -ENOSUP
    def getattr(self):
        mode = 0555
        #FIXME: empty dir stat needed
        pass
    def getxattr(self,name):
        if size:
            return 0
        return ""
    def link(self,nodeold,parentnew):
        return -ENOSUP
    def listxattr(self):
        if size:
            return 0
        return []
    def mkdir(self,modei,parent):
        return -EPERM
    def open(self,parent,flags,*mode):
        return -ENOSUP
    def read(length,offset):
        return -ENOSUP
    def readdir(self):
        return []
    def readlink(self):
        return -ENOSUP
    def release(self,flags):
        return -ENOSUP
    def rename(self,nodenew,parentold,parentnew):
        return -EPERM
    def rmdir(self,parent):
        return -EPERM
    def setMeta(self,rwcap,rocap,cryptokey):
        pass
    def symlink(self,pathold,parentnew):
        return -ENOSUP
    def touch(self):
        return -EPERM
    def truncate(self,len):
        return -ENOSUP
    def unlink(self,parent):
        return -EPERM
    def write(self,buf,offset):
        return -ENOSUP

class FileNode:
    def __init__(self,basenode):
        self.basenode=basenode
        self.mFile=None
    def access(self,mode):
        return True
    def chmod(self,mode):
        self.basenode.chmod(mode)
    def exists(self):
        return self.basenode.exists()
    def isDir(self):
        return False
    def isFile(self):
        return self.basenode.exists()
    def isLink(self):
        return False
    def flush(self):
        if self.mFile != None: 
            return self.mFile.flush()
        else:
            return -ENOSUP
    def fsync(self,isfssyncfile):
        if self.mFile != None:
            return self.mFile.fsync(isfssyncfile)
        else:
            return -ENOSUP
    def getattr(self):
        return self.basenode.getattr()
    def getxattr(self,name):
        return self.basenode.getxattr(name)
    def link(self,nodeold,parentnew):
        return -EEXIST
    def listxattr(self):
        return self.basenode.listxattr()
    def mkdir(self,modei,parent):
        return -EPERM
    def open(self,parent,flags,*mode):
        try:
            self.mFile = self.basenode.open(parent,flags,*mode)
            return 0
        except:
            return self.basenode.getErrno()
    def read(self,length,offset):
        if self.mFile != None:
            return self.mFile.read(length,offset)
        else:
            return -ENOSUP
    def readdir(self):
        return -ENOSUP
    def readlink(self):
        return -ENOSUP
    def release(self,flags):
        if self.mFile != None:
            return self.mFile.release(flags)
        else:
            return -ENOSUP
    def rename(self,nodenew,parentold,parentnew):
        return self.basenode.rename(nodenew,parentold,parentnew)
    def rmdir(self,parent):
        return -ENOSUP
    def setMeta(self,rwcap,rocap,cryptokey):
        return self.basenode.setMeta(rwcap,rocap,cryptokey)
    def symlink(self,pathold,parentnew):
        return -EPERM
    def touch(self):
        return self.basenode.touch()
    def truncate(self,len):
        return self.basenode.truncate(len)
    def unlink(self,parent):
        return self.basenode.unlink(parent)
    def write(self,buf,offset):
        if self.mFile != None:
            return self.mFile.write(buf,offset)
        else:
            return -ENOSUP

class DirNode:
    def __init__(self,basenode):
        self.basenode=basenode
    def access(self,mode):
        return True
    def chmod(self,mode):
        return 0
    def exists(self):
        return True
    def isDir(self):
        return True
    def isFile(self):
        return False
    def isLink(self):
        return False
    def flush(self):
        return -ENOSUP
    def fsync(isfssyncfile):
        return -ENOSUP
    def getattr(self):
        return self.basenode.getattr()
    def getxattr(self,name):
        return self.basenode.getxattr(name)
    def link(self,nodeold,parentnew):
        return -EEXIST
    def listxattr(self):
        return self.basenode.listxattr()
    def mkdir(self,modei,parent):
        return -EEXIST
    def open(self,parent,flags,*mode):
        return -ENOSUP
    def read(length,offset):
        return -ENOSUP
    def readdir(self):
        jsondata=self.basenode.allData()
        return json.loads(infile)
    def readlink(self):
        return -ENOSUP
    def release(self,flags):
        return -ENOSUP
    def rename(self,nodenew,parentold,parentnew):
        return self.basenode.rename(nodenew,parentold,parentnew)
    def rmdir(self,parent):
        jsondata=self.basenode.allData()
        entries=json.loads(infile)
        if len(entries) > 0:
            return -ENOTEMPTY
        return self.basenode.removedir(parent)
    def setMeta(self,rwcap,rocap,cryptokey):
        return self.basenode.setMeta(rwcap,rocap,cryptokey)
    def symlink(self,pathold,parentnew):
        return -EPERM
    def touch(self):
        return self.basenode.touch()
    def truncate(self,len):
        return -ENOSUP
    def unlink(self,parent):
        return -ENOSUP
    def write(self,buf,offset):
        return -ENOSUP

class LinkNode:
    def __init__(self,basenode):
        self.basenode=basenode
    def access(self,mode):
        return self.basenode.access(mode)
    def chmod(self,mode):
        return 0
    def exists(self):
        return True
    def isDir(self):
        return False
    def isFile(self):
        return False
    def isLink(self):
        return True
    def flush(self):
        return -ENOSUP
    def fsync(self,isfssyncfile):
        return -ENOSUP
    def getattr(self):
        return self.basenode.getattr()
    def getxattr(self,name):
        return self.basenode.getxattr(name)
    def link(self,nodeold,parentnew):
        return -EPERM
    def listxattr(self):
        return self.basenode.listxattr()
    def mkdir(self,modei,parent):
        return -EPERM
    def open(self,parent,flags,*mode):
        return -ENOSUP
    def read(self,length,offset):
        return -ENOSUP
    def readdir(self):
        return -ENOSUP
    def readlink(self):
        jsondata=self.basenode.allData()
        return json.loads(infile)[0]
    def release(self,flags):
        return -ENOSUP
    def rename(self,nodenew,parentold,parentnew):
        return self.basenode.rename(nodenew,parentold,parentnew)
    def rmdir(self,parent):
        return -ENOSUP
    def setMeta(self,rwcap,rocap,cryptokey):
        return self.basenode.setMeta(rwcap,rocap,cryptokey)
    def symlink(self,pathold,parentnew):
        return -EEXIST
    def touch(self):
        return self.basenode.touch()
    def truncate(self,len):
        return -ENOSUP
    def unlink(self,parent):
        return self.basenode.unlink(parent)
    def write(self,buf,offset):
        return -ENOSUP

class PreNode:
    def __init__(self,basenode):
        self.basenode=basenode
        self.mFile=None
    def access(self,mode):
        return -ENOENT
    def chmod(self,mode):
        return -ENOENT
    def exists(self):
        return False
    def isDir(self):
        return False
    def isFile(self):
        return False
    def isLink(self):
        return False
    def flush(self):
        if self.mFile != None:
            return self.mFile.flush()
        else:
            return -ENOSUP    
    def fsync(self,isfssyncfile):
        if self.mFile != None:
            return self.mFile.fsync(isfssyncfile)()
        else:
            return -ENOSUP
    def getattr(self):
        if self.mFile != None:
            return self.mFile.getattr()
        else:
            return -ENOSUP
    def getxattr(self,name):
        return -ENOENT
    def has_key(self,key):
        #FIXME: check if dir contents has a named entry.
        pass
    def link(self,nodeold,parentnew):
        return self.basenode.link(nodeold,parentnew)
    def listxattr(self):
        return -ENOENT
    def mkdir(self,modei,parent):
        #FIXME: create empty dir json and create our new node with it as contents (mode 0760 for dir).
        pass
    def open(self,parent,flags,*mode):
        if flags & os.O_CREAT:
            try:
                self.mFile = self.basenode.open(parent,flags,*mode)
                return 0
            except:
                return self.basenode.getErrno()
        else:
            return -ENOENT    
    def read(self,length,offset):
        if self.mFile != None:
            return self.mFile.read(length,offset)
        else:
            return -ENOSUP
    def readdir(self):
        return -ENOENT
    def readlink(self):
        return -ENOENT
    def removeentry(self,name):
        #FIXME: realy remove entry from directory json and write back.
        pass
    def release(self,flags):
        if self.mFile != None:
            return self.mFile.release(flags)
        else:
            return -ENOSUP
    def rename(self,nodenew,parentold,parentnew):
        return -ENOENT
    def rmdir(self,parent):
        return -ENOENT
    def setMeta(self,rwcap,rocap,cryptokey):
        return self.basenode.setMeta(rwcap,rocap,cryptokey)
    def symlink(self,pathold,parentnew):
        #FIXME: create link json and create our new node with it as contents (mode 0770 for file).
        pass
    def touch(self):
        return -ENOENT
    def truncate(self,len):
        if self.mFile != None:
            return self.mFile.truncate(len)
        else:
            return -ENOSUP
    def unlink(self,parent):
        return -ENOENT
    def write(self,buf,offset):
        if self.mFile != None:
            return self.mFile.write(buf,offset)
        else:
            return -ENOSUP


class RawStorageRootDir:
    def __init__(self,rootdir):
        self.rootdir=rootdir
    def pathToNode(self,relpath):
        rawnode=RawStorageNode(self.rootdir,relpath)
        if rawnode.exists():
            if rawnode.isFile():
                return FileNode(rawnode)
            if rawnode.isDir():
                return DirNode(rawnode)
            if rawNode.isLink():
                return LinkNode(rawnode)
        if rawnode.creatable():
            return PreNode(rawnode) 
        return NoNode()

class CapFs(fuse.Fuse):
    def __init__(self,lookup):
        self.lookup=lookup
        fuse.Fuse.__init__(self)
        class CapFsFile(object):
            def __init__(self, path, flags, *mode):
                self.node=lookup(path,True)
                parent=lookup(os.path.dirname(path))
                return self.node.open(parent,flags,*mode)
            def read(self, length, offset):
                return self.node.read(length, offset)
            def write(self, buf, offset):
                return self.node.write(buf, offset)
            def release(self, flags):
                return self.node.release(flags)
            def fsync(self, isfsyncfile):
                return self.node.fsync(isfsyncfile)
            def flush(self):
                return self.node.flush()
            def fgetattr(self):
                return self.node.getattr()
            def ftruncate(self, len):
                return self.node.truncate(len)
        self.file_class = CapFsFile
    def getattr(self, path):
        node=self.lookup(path)
        return node.getattr()
    def readlink ( self, path ):
        node=self.lookup(path)
        return node.readlink()
    def readdir(self,path,offset):
        node=self.lookup(path)
        return node.readdir()
    def unlink(self,path):
        node=self.lookup(path)
        parent=lookup(os.path.dirname(path))
        return node.unlink(parent)
    def rmdir(self,path):
        node=self.lookup(path)
        parent=lookup(os.path.dirname(path))
        return node.rmdir(parent)
    def symlink(self,pathold,pathnew):
        nodenew=self.lookup(pathnew,True)
        parentnew=lookup(os.path.dirname(pathnew))
        return nodenew.symlink(pathold,parentnew)
    def rename(self,pathold,pathnew):
        nodeold=self.lookup(pathold)
        parentold=lookup(os.path.dirname(pathold))
        nodenew=self.lookup(path1,True)
        parentnew=lookup(os.path.dirname(pathnew))
        return nodeold.rename(nodenew,parentold,parentnew)
    def link(self,pathold,pathnew):
        nodeold=self.lookup(pathold)
        nodenew=self.lookup(pathnew)
        parentnew=self.lookup(os.path.dirname(pathnew))
        return nodenew.link(nodeold,parentnew)
    def chmod(self,path,mode):
        node=self.lookup(path)
        return node.chmod(mode)
    def chown(self,path,user,group):
        return -EPERM
    def truncate(self,path,len):
        node=self.lookup(path)
        node.truncate(len)
    def mknod(self,path,mode,dev):
        return -EPERM
    def mkdir(self,path,mode):
        node=self.lookup(path)
        parent=self.lookup(os.path.dirname(path))
        return node.mkdir(mode,parent)
    def utime(self,path,times):
        node=self.lookup(path)
        return node.touch()
    def access(self,path,mode):
        node=self.lookup(path)
        return self.access(mode)
    def getxattr(self,path,name,size):
        node=self.lookup(path)
        xattr=node.getxattr(name)
        if size== 0:
            return len(xattr)
        return xattr
    def listxattr(self,path,size):
        node=self.lookup(path)
        attrlist=node.listxattr()
        if size == 0:
            return len(attrlist)+len("".join(attrlist))
        else:
            return attrlist
    def statfs(self):
        return self.lookup.statfs()

if __name__ == "__main__":
    configpath="/etc/minorfs/capfs.json"
    if not os.path.exists(configpath):
        print "ERROR: MinorFS2 was not installed properly,",configpath," is missing."
        exit(1)
    try:
        infile=open(configpath,"r")
    except IOError:
        print "ERROR: Unexpected IO error trying to open existing config " + configpath
        sys.exit(2)
    try:
        conf=json.load(infile)
    except ValueError:
        print "ERROR: The content of " + configpath + " is not valid json."
        sys.exit(3)
    infile.close()
    if not conf.has_key("salt"):
        print "ERROR: " + configpath + " does not contain a 'salt' section."
        sys.exit(4)
    salt=conf["salt"]
    if len(salt) != 52:
        print "ERROR: " + configpath + " value of 'salt' should be a 52 byte base32 string."
        sys.exit(5)
    try:
        rawsalt=base64.b32decode(salt + "====")
    except TypeError:
        print "ERROR: " + configpath + " value of 'salt' is not a valid base32 string."
        sys.exit(6)
    if not conf.has_key("datadir"):
        print "ERROR: " + configpath + " does not contain a 'datadir' section."
        sys.exit(7)
    datadir=conf["datadir"]
    if not os.path.isdir(datadir):
        print "ERROR: " + configpath + " value of 'datadir' does not point to an existing directory."
        sys.exit(9)
    if not os.access(datadir, os.W_OK):
        print "ERROR: " + configpath + " value of 'datadir' points to a directory that is not writable to the current user."
        sys.exit(9)
    if not conf.has_key("mountpoint"):
        print "ERROR: " + configpath + " does not contain a 'mountpoint' section."
        sys.exit(10)
    mountpoint=str(conf["mountpoint"])
    if not os.path.isdir(mountpoint):
        print "ERROR: " + configpath + " value of 'mountpoint' does not point to an existing directory."
        sys.exit(9)
    
    rawstoragerootdir=RawStorageRootDir(datadir)
    lookup=Lookup(rawstoragerootdir,rawsalt)
    capfs=CapFs(lookup)
    capfs.flags = 0
    capfs.multithreaded = 0
    capfs.fuse_args.add('allow_other')
    capfs.fuse_args.setmod('foreground')
    capfs.fuse_args.mountpoint = mountpoint
#   capfs.main()

