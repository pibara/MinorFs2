#!/usr/bin/python
import fuse
fuse.fuse_python_api = (0, 2)
import hashlib
import base64
import os
import stat
import json
import sys
import errno
class Lookup:
    def __init__(self,rawstorage,salt):
        self.rawstorage = rawstorage
        self.salt=salt
    def statfs(self):
        return os.statvfs(self.rawstorage)
    def __call__(self,accesstoken,relpath,succeedcreatable):
        #A valid basecap is 55 characters long.
        if len(accesstoken) != 55:
            return NoNode()
        #The access token starts with either 'rw-' or 'ro-'
        mode=accesstoken[:2]
        #The rest is the base32 representation of a 256 bit key.
        basecapb32=accesstoken[3:]
        #Turn it into a raw 256 bit key.
        try:
            basecapraw=base64.b32decode(basecapb32 + "====")
        except TypeError:
            return NoNode()
        #Initialize the base keys to None.
        rwcap=None
        rocap=None
        cryptokey=None
        if (mode=='rw'):
            #If its a read only token, remember that
            readonly = False
            #Remember the base32 key as rw-cap
            rwcap=accesstoken
            #Calculate the crypto-key key from the raw read/write key and our secret salt.
            cryptokey = str(hashlib.sha256(basecapraw + self.salt ).digest())
            #The read-only key is the base32 of the crypto-key.
            rocap = "ro-" + base64.b32encode(cryptokey)[:52]
        elif (mode=='ro'):
            #If its a read/write access token, remember that.
            readonly = True
            #The crypto-key is the raw basecap.
            cryptokey== basecapraw
            #The supplied basecap is our read only cap.
            rocap=accesstoken
        else:
            #Anything else is bogus.
            return NoNode()
        #Set parentrocap to None in case whe have an empty relpath.
        parentcryptokey=None
        for subnodename in relpath.split("/"):
            #Remember the last parent cryptokey, we may need it later on.
            parentcryptokey=cryptokey
            #Calculate all relevant caps from the parent ro cap and the subnode name.
            rwkey=str(hashlib.sha256( parentcryptokey + self.salt + subnodename ).digest())
            cryptokey=str(hashlib.sha256( rwkey + self.salt ).digest())
        #Now first look at the leaf node only, calculate the storage key, storage path and check it it exists.
        storagekey = base64.b32encode(str(hashlib.sha256(cryptokey + self.salt ).digest()))[:52]  
        storagepath = "/" + storagekey[:2] + "/" + storagekey[2:4] + "/" + storagekey[4:]      
        basenode = self.rawstorage.pathToNode(storagepath)
        if not basenode.exists():
            if succeedcreatable:
                #If it does not exist, that might be OK if the succeedcreatable function argument is set.
                if parentrocap:
                    #If we do have a parent node but our current node does not exist and is directory,than at least our parent node MUST exist.
                    parentstoragekey = base64.b32encode(str(hashlib.sha256(parentcryptokey + self.salt ).digest()))[:52]
                    parentstoragepath = "/" + parentstoragekey[:2] + "/" + parentstoragekey[2:4] + "/" + parentstoragekey[4:]
                    parentbasenode = self.rawstorage.pathToNode(parentstoragepath)
                    if not parentbasenode.isDir():
                        #If it doesn't, the whole path must be bogus.
                        return NoNode()
            else:
                return NoNode()
        #If relpath wasn't empty, calculate the new base32 versions of the relevant keys.
        if not parentcryptokey == None:
            rwcap="rw-" + base64.b32encode(rwkey)[:52]
            rocap="ro-" + base64.b32encode(cryptokey)[:52]
        #Now set the crypto key and the read only flag for the node before we return it.
        if readonly:
            basenode.setMeta(None,rocap,cryptokey)
            return ReadOnlyProxy(basenode)
        else:
            basenode.setMeta(rwcap,rocap,cryptokey)
            return basenode

class Node:
    def __init__(self,rootdir,relpath):
        self.initialized=False
        self.exists=False
        self.nodetype=0
        fullpath=rootdir + relpath
        if os.path.exists(fullpath):
            self.exists=True
            #Fixme: explain this
            self.nodetype = (os.stat(fullpath).st_mode & 070) >> 3
    def exists(self):
        return self.exists
    def isFile(self):
        return self.nodetype==4
    def isDir(self):
        return self.nodetype==6
    def isLink(self):
        return self.nodetype==7
    def setMeta(self,rwcap,rocap,cryptokey):
        if not self.initialized:
            self.initialized = True
            self.rwcap=rwcap
            self.rocap=rocap
            self.cryptokey=cryptokey
        return
    def getattr(self):
        pass
    def readlink(self):
        pass
    def readdir(self):
        pass
    def unlink(self):
        pass
    def rmdir(self):
        pass
    def symlink(self,path1):
        pass
    def rename(self,node):
        pass
    def link(self,node):
        pass
    def chmod(self,mode):
        pass
    def truncate(self,len):
        pass
    def mkdir(self,mode):
        pass
    def touch(self):
        pass
    def access(self,mode):
        pass
    def getxattr(self,name,size):
        pass
    def listxattr(self,size):
        pass 

class RootDir:
    def __init__(self,rootdir):
        self.rootdir=rootdir
    def pathToNode(self,relpath):
        rawnode=StorageNode(self.rootdir,relpath)
        if rawnode.exists():
            if rawnode.isFile():
                return FileNode(rawnode)
            if rawnode.isDir():
                return DirNode(rawnode)
            if rawNode.isLink():
                return LinkNode(rawnode)
        if rawnode.creatable():
            return PreNode(rawnode) 
        return NoNode()

class CapFs(fuse.Fuse):
    def __init__(self,lookup):
        self.lookup=lookup
        fuse.Fuse.__init__(self)
        class CapFsFile(object):
            def __init__(self, path, flags, *mode):
                self.node=lookup(path)
                return self.node.open(flags,*mode)
            def read(self, length, offset):
                return self.node.read(length, offset)
            def write(self, buf, offset):
                return self.node.write(buf, offset)
            def release(self, flags):
                return self.node.release(flags)
            def fsync(self, isfsyncfile):
                return self.node.fsync(isfsyncfile)
            def flush(self):
                return self.node.flush()
            def fgetattr(self):
                return self.node.getattr()
            def ftruncate(self, len):
                return self.node.truncate(len)
        self.file_class = CapFsFile
    def getattr(self, path):
        node=self.lookup(path)
        return node.getattr()
    def readlink ( self, path ):
        node=self.lookup(path)
        return node.readlink()
    def readdir(self,path,offset):
        node=self.lookup(path)
        return node.readdir()
    def unlink(self,path):
        node=self.lookup(path)
        return node.unlink()
    def rmdir(self,path):
        node=self.lookup(path)
        return node.rmdir()
    def symlink(self,path,path1):
        node=self.lookup(path)
        node.symlink(path1)
    def rename(self,path,path1):
        node1=self.lookup(path)
        node2=self.lookup(path1)
        return node1.rename(node2)
    def link(self,path,path1):
        node1=self.lookup(path)
        node2=self.lookup(path1)
        return node1.link(node2)
    def chmod(self,path,mode):
        node=self.lookup(path)
        return node.chmod(mode)
    def chown(self,path,user,group):
        return -EPERM
    def truncate(self,path,len):
        node=self.lookup(path)
        node.truncate(len)
    def mknod(self,path,mode,dev):
        return -EPERM
    def mkdir(self,path,mode):
        node=self.lookup(path)
        return node.mkdir(mode)
    def utime(self,path,times):
        node=self.lookup(path)
        return node.touch()
    def access(self,path,mode):
        node=self.lookup(path)
        return self.access(mode)
    def getxattr(self,path,name,size):
        node=self.lookup(path)
        return node.getxattr(name,size)
    def listxattr(self,path,size):
        node=self.lookup(path)
        return node.listxattr(size)
    def statfs(self):
        return self.lookup.statfs()

if __name__ == "__main__":
    configpath="/etc/minorfs/capfs.json"
    if not os.path.exists(configpath):
        print "ERROR: MinorFS2 was not installed properly,",configpath," is missing."
        exit(1)
    try:
        infile=open(configpath,"r")
    except IOError:
        print "ERROR: Unexpected IO error trying to open existing config " + configpath
        sys.exit(2)
    try:
        conf=json.load(infile)
    except ValueError:
        print "ERROR: The content of " + configpath + " is not valid json."
        sys.exit(3)
    infile.close()
    if not conf.has_key("salt"):
        print "ERROR: " + configpath + " does not contain a 'salt' section."
        sys.exit(4)
    salt=conf["salt"]
    if len(salt) != 52:
        print "ERROR: " + configpath + " value of 'salt' should be a 52 byte base32 string."
        sys.exit(5)
    try:
        rawsalt=base64.b32decode(salt + "====")
    except TypeError:
        print "ERROR: " + configpath + " value of 'salt' is not a valid base32 string."
        sys.exit(6)
    if not conf.has_key("datadir"):
        print "ERROR: " + configpath + " does not contain a 'datadir' section."
        sys.exit(7)
    datadir=conf["datadir"]
    if not os.path.isdir(datadir):
        print "ERROR: " + configpath + " value of 'datadir' does not point to an existing directory."
        sys.exit(9)
    if not os.access(datadir, os.W_OK):
        print "ERROR: " + configpath + " value of 'datadir' points to a directory that is not writable to the current user."
        sys.exit(9)
    if not conf.has_key("mountpoint"):
        print "ERROR: " + configpath + " does not contain a 'mountpoint' section."
        sys.exit(10)
    mountpoint=str(conf["mountpoint"])
    if not os.path.isdir(mountpoint):
        print "ERROR: " + configpath + " value of 'mountpoint' does not point to an existing directory."
        sys.exit(9)
    
    rootdir=RootDir(datadir)
    lookup=Lookup(rootdir,rawsalt)
    capfs=CapFs(lookup)
    capfs.flags = 0
    capfs.multithreaded = 0
    capfs.fuse_args.add('allow_other')
    capfs.fuse_args.setmod('foreground')
    capfs.fuse_args.mountpoint = mountpoint
    capfs.main()

