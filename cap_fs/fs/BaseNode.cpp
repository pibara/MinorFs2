//  Copyright (c) 2012, Rob J Meijer
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.
#include "BaseNode.hpp"
#include <string.h>
#include <sys/types.h>
#include <attr/xattr.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
namespace capfs {
namespace fs {
BaseNode::BaseNode():
       mAccess(false),mRelPath(""){}
BaseNode::BaseNode(std::string relpath):
       mAccess(true),mRelPath(relpath){}
BaseNode::BaseNode(capfs::algo::TripleHashParentChild pc):mAccess(true),mRelPath(""),mParentChild(pc){}
int BaseNode::stat(struct stat *s) { 
  if (mAccess == false) {
    return -EPERM;
  }
  if (mRelPath == "/") {
     memset(s, 0, sizeof(struct stat));
     s->st_mode = S_IFDIR | 0755;
     s->st_nlink = 3; 
     return 0;
  }
  if (mParentChild.child()) {
     //Stat the underlying raw storage filsystem node.
     int rval=lstat(mParentChild.child().rawpath().c_str(), s);
     //If the raw node does not exist, return the error code.
     if (rval == -1)
        return -errno;
     //Before overwriting the mode, save the group bits and the owner exe bit.
     mode_t groupbits=s->st_mode & 0070;
     bool executable = ((s->st_mode & 00100) == 00100);
     //The groupbits contain piggybacked node type information.
     s->st_mode =0;
     if (groupbits==0060) { //Dir
        s->st_mode |= S_IFDIR;
     } else if (groupbits==0070) { //Symlink
        s->st_mode |= S_IFLNK;
     }
     //The The readable bits are always set, the owner executable bit is extended to group and others. 
     if (executable) {
        s->st_mode |= 00555;
     } else {
        s->st_mode |= 00444;
     }
     //If the triplehashnode is writable, set all writable bits.
     if (mParentChild.child().canWrite()) {
        s->st_mode |= 00222;
     }
     return 0;     
  }
  return -ENOENT;  
}
int BaseNode::chmod(mode_t m) {
  if (mAccess == false) {
    return -EPERM;
  }
  //No chmod on the filesystems root node.
  if (mRelPath == "/") {
     return -EPERM;
  }
  //On other nodes chmod is allowed but ignores all but the owner executable bit.
  if (mParentChild.child()) {
    //Stat the raw node to get the old mode.
    struct stat statdata;
    struct stat *s=&statdata;
    int rval=lstat(mParentChild.child().rawpath().c_str(), s);
    //If the raw node does not exist, return the error code.
    if (rval == -1)
        return -errno;
    //Determine the new mode based on the old mode and the desired owner executable bit.
    mode_t newmode = s->st_mode;
    if (m & 00100) {
       newmode = s->st_mode | 00100;
    } else {
       newmode = s->st_mode & (~(00100));
    }
    //Chmod the raw node.
    rval=::chmod(mParentChild.child().rawpath().c_str(),newmode);
    //If chmod fails, return error code.
    if (rval == -1)
        return -errno;
    return 0;
  } 
  return -ENOENT;

}
int BaseNode::listxattr(char *l, size_t s) {
  if (mAccess == false) {
    return -EPERM;
  }
  if (mRelPath == "/") {
     return -EPERM;
  }
  if (mParentChild.child()) {
    bool rw=mParentChild.child().canWrite();
    size_t neededsize=7;
    if (rw) {
       neededsize +=6;
    }
    if (s < neededsize) {
      return -ERANGE;
    }
    memset(l,0,neededsize);
    strcpy(l,"rocap");
    if (rw) {
      strcpy(l+6,"rwcap");
    }
    return neededsize;
  }
  return -ENOENT;
}
int BaseNode::getxattr(const char *n, char *v, size_t s)  {
  if (mAccess == false) {
    return -EPERM;
  }
  if (mRelPath == "/") {
     return -EPERM;
  }
  if (mParentChild.child()) {
     if (strcmp(n,"rocap")==0) {
       std::string cap=mParentChild.child().rocap();
       if (s < (cap.size() +1)) {
         return -ERANGE;
       }
       strcpy(v,cap.c_str());
       return cap.size() +1;
     }
     if (strcmp(n,"rwcap")==0) {
       std::string cap=mParentChild.child().rwcap(); 
       if (s < (cap.size() +1)) {
         return -ERANGE;
       }
       strcpy(v,cap.c_str());
       return cap.size() +1;
     }
     return -ENOATTR;
  }
  return -ENOENT;
}
int BaseNode::access(int m) {
  if (mAccess == false) {
    return -EPERM;
  }
  if (mRelPath == "/") {
    if (m & W_OK) {
      return -EACCES;
    }
    return 0;
  }
  if (mParentChild.child()) {
    if ((m & W_OK) and not (mParentChild.child().canWrite())) {
       return -EACCES;
    }
    if (m & X_OK) {
       struct stat statdata;
       struct stat *s=&statdata;
       int rval=lstat(mParentChild.child().rawpath().c_str(), s);
       //If the raw node does not exist, return the error code.
       if (rval == -1) {
          return -EACCES;
       }
       if ((s->st_mode & 00100) != 00100) {
          return -EACCES; 
       }
    }
    return 0;
  }
  return -ENOENT;
}
int BaseNode::readlink(char *b, size_t l) { 
  if (mAccess == false) {
    return -EPERM;
  }
  if (mRelPath == "/") {
    return -ENOTSUP;
  }
  if (mParentChild.child()) {
     return -ENOTSUP; //TODO
  }
  return -ENOENT;
}
int BaseNode::mknod(mode_t m, dev_t d) { 
  if (mAccess == false) {
    return -EPERM;
  } 
  if (mRelPath == "/") {
    return -ENOTSUP;
  }
  if (mParentChild.child()) {
    struct stat statdata;
    struct stat *s=&statdata;
    int rval=lstat(mParentChild.child().rawpath().c_str(), s);
    //If the raw node does exist, return an error code.
    if (rval != -1) {
       return -EEXIST;
    }
    //Check if the parent node exists
    if ((not mParentChild.parent())||(not mParentChild.child().canWrite())) {
       return -EPERM;
    }
    rval=lstat(mParentChild.parent().rawpath().c_str(), s);
    if (rval == -1) {
       return -ENOENT;
    }
    //Check if parent is a directory.
    if ((s->st_mode & 0070) != 0060) {
       return -ENOTDIR;
    }
    //Now first create the new node.
    if (m & S_IFREG) {
       //Make sure all inbetween dirs exist.
       ::mkdir(mParentChild.child().d1().c_str(),0700);
       ::mkdir(mParentChild.child().d2().c_str(),0700);
       //Determine the mode for the new node.
       mode_t newfilemode=00640 | (m & 00100);
       //Create the raw node.
       rval=::mknod(mParentChild.child().rawpath().c_str(),newfilemode,d);
       if (rval == -1) {
          return -errno;
       }
    }
    else {
       //FIXME: For now no support for S_IFCHR,S_IFBLK,S_IFIFO or S_IFSOCK, fix this later.
       return -EPERM;
    }
    //Add an entry to the parent directory.
    //FIXME: Implement adding to directory.
    return 0;
  }
  return -ENOENT;
}
int BaseNode::mkdir(mode_t m,bool cancreateroot) { 
  if (mAccess == false) {
    return -EPERM;
  }
  if (mRelPath == "/") {
    return -ENOTSUP;
  }
  if (mParentChild.child()) {
    struct stat statdata;
    struct stat *s=&statdata;
    if (mParentChild.parent()) {
      //For non sparse-cap node's, the parent node must exist and be a directory.
      int rval=lstat(mParentChild.parent().rawpath().c_str(), s);
      if (rval == -1) {
         return -ENOENT;
      }
      if ((s->st_mode & 0070) != 0060) {
       return -ENOTDIR;
      }
    } else {
      if (not cancreateroot) {
         return -EPERM;
      }
    }
    int rval=lstat(mParentChild.child().rawpath().c_str(), s);
    //If the raw node does exist, return an error code.
    if (rval != -1) {
       return -EEXIST;
    }
    //Make sure all inbetween dirs exist.
    ::mkdir(mParentChild.child().d1().c_str(),0700);
    ::mkdir(mParentChild.child().d2().c_str(),0700);
    //Create an empty directory file for our new directory.
    rval=::mknod(mParentChild.child().rawpath().c_str(),00760,0);
    if (rval == -1) {
      return -errno;
    }
    if (mParentChild.parent()) {
        //Add an entry to the parent directory.
        //FIXME: Implement adding to parent directory.
    }
    return 0;
  }
  return -EPERM;
}

int BaseNode::unlink() { return -EPERM;}
int BaseNode::rmdir() { return -EPERM;}
int BaseNode::symlink(std::string l) {return -EPERM;}
int BaseNode::rename(BaseNode l) {return -EPERM;}
int BaseNode::link(BaseNode l) {return -EPERM;}
int BaseNode::truncate(off_t off) {return -EPERM;}
int BaseNode::bmap(size_t blocksize, uint64_t *idx) {return -EPERM;}
int BaseNode::open(uint64_t *fh,int flags) {return -EPERM;}
int BaseNode::opendir(uint64_t *fh)  {
  if (mAccess == false) {
    return -EPERM;
  }
  if (mRelPath == "/") {
    *fh=0;  //We use zero as special root dir dir handle.
    return 0;
  }
  return -ENOENT;
}
int BaseNode::create(uint64_t *fh,mode_t m) {return -EPERM;}
}
}
