//  Copyright (c) 2012, Rob J Meijer
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.
#include "BaseNode.hpp"
#include <string.h>
#include <sys/types.h>
#include <attr/xattr.h>
#include <sys/stat.h>
#include <unistd.h>
namespace capfs {
namespace fs {
BaseNode::BaseNode():mAccess(false),mRelPath(""){}
BaseNode::BaseNode(std::string relpath):mAccess(true),mRelPath(relpath){}
BaseNode::BaseNode(capfs::algo::TripleHashParentChild pc):mAccess(true),mRelPath(""),mParentChild(pc){}
int BaseNode::stat(struct stat *s) { 
  if (mAccess == false) {
    return -EPERM;
  }
  if (mRelPath == "/") {
     memset(s, 0, sizeof(struct stat));
     s->st_mode = S_IFDIR | 0755;
     s->st_nlink = 3; 
     return 0;
  }
  if (mParentChild.child()) {
     //Stat the underlying raw storage filsystem node.
     int rval=lstat(mParentChild.child().rawpath().c_str(), s);
     //If the raw node does not exist, return the error code.
     if (rval == -1)
        return -errno;
     //Before overwriting the mode, save the group bits and the owner exe bit.
     mode_t groupbits=s->st_mode & 0070;
     bool executable = ((s->st_mode & 00100) == 00100);
     //The groupbits contain piggybacked node type information.
     s->st_mode =0;
     if (groupbits==0060) { //Dir
        s->st_mode |= S_IFDIR;
     } else if (groupbits==0070) { //Symlink
        s->st_mode |= S_IFLNK;
     }
     //The The readable bits are always set, the owner executable bit is extended to group and others. 
     if (executable) {
        s->st_mode |= 00555;
     } else {
        s->st_mode |= 00444;
     }
     //If the triplehashnode is writable, set all writable bits.
     if (mParentChild.child().canWrite()) {
        s->st_mode |= 00222;
     }
     return 0;     
  }
  return -ENOENT;  
}
int BaseNode::readlink(char *b, size_t l) { return -EPERM;}
int BaseNode::mknod(mode_t m, dev_t d) { return -EPERM;}
int BaseNode::mkdir(mode_t m) { return -EPERM;}
int BaseNode::unlink() { return -EPERM;}
int BaseNode::rmdir() { return -EPERM;}
int BaseNode::symlink(std::string l) {return -EPERM;}
int BaseNode::rename(BaseNode l) {return -EPERM;}
int BaseNode::link(BaseNode l) {return -EPERM;}
int BaseNode::chmod(mode_t m) {
  if (mAccess == false) {
    return -EPERM;
  }
  //No chmod on the filesystems root node.
  if (mRelPath == "/") {
     return -EPERM;
  }
  //On other nodes chmod is allowed but ignores all but the owner executable bit.
  if (mParentChild.child()) {
    //Stat the raw node to get the old mode.
    struct stat statdata;
    struct stat *s=&statdata;
    int rval=lstat(mParentChild.child().rawpath().c_str(), s);
    //If the raw node does not exist, return the error code.
    if (rval == -1)
        return -errno;
    //Determine the new mode based on the old mode and the desired owner executable bit.
    mode_t newmode = s->st_mode;
    if (m & 00100) {
       newmode = s->st_mode | 00100;
    } else {
       newmode = s->st_mode & (~(00100));
    }
    //Chmod the raw node.
    rval=::chmod(mParentChild.child().rawpath().c_str(),newmode);
    //If chmod fails, return error code.
    if (rval == -1)
        return -errno;
    return 0;
  } 
  return -EPERM;

}
int BaseNode::truncate(off_t off) {return -EPERM;}
int BaseNode::getxattr(const char *n, char *v, size_t s)  {
  return -ENOATTR;
}
int BaseNode::listxattr(char *l, size_t s) {return -EPERM;}
int BaseNode::access(int m) {return -EPERM;}
int BaseNode::bmap(size_t blocksize, uint64_t *idx) {return -EPERM;}
int BaseNode::open(uint64_t *fh,int flags) {return -EPERM;}
int BaseNode::opendir(uint64_t *fh)  {
  if (mAccess == false) {
    return -EPERM;
  }
  if (mRelPath == "/") {
    *fh=0;  //We use zero as special root dir dir handle.
    return 0;
  }
  return -ENOENT;
}
int BaseNode::create(uint64_t *fh,mode_t m) {return -EPERM;}
}
}
